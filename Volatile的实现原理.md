### Volatile的实现原理

### 保证内存的可见性
### 防止重排序


> 1.将当前处理器缓存行的数据会写回到系统内存。
> 2.这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。

> 处理器为了提高处理速度，不直接和内存进行通讯，而是先将系统内存的数据读到内部缓存（L1,L2或其他）后再进行操作，但操作完之后不知道何时会写到内存，如果对声明了Volatile变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。

### 系统内存 -> 内部缓存（L1,L2或其他） -> CPU
> CPU不直接和系统内存打交道，因为系统内存太慢了

> 不会引起上下文切换











































